<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Mehul Tikekar - On functional programming</title>
        <meta name="viewport" content="width=device-width" />
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Mehul Tikekar</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../research.html">Research</a>
                <a href="../contact.html">Contact</a>
                <a id="active" href="../blog.html">Blog</a>
            </div>
            <span id="boom"></span>
        </div>

        <div id="content">
            <h1>On functional programming</h1>

            <div class="info">
    Posted on October  8, 2013
    
</div>

<p>Functional programming is often associated with languages that have features like:</p>
<ol style="list-style-type: decimal">
<li>Anonymous functions - the <code>function (arg1) {...}</code> style callbacks of JavaScript or the <code>lambda</code> of Python.</li>
<li>Lazy evaluation - Python's generator expressions <code>(2*i for i in list1)</code> which are iterators that compute new values only when required.</li>
<li>Higher order functions - functions that take other functions as arguments and/or return functions. For example, the famous <code>map</code> and <code>reduce</code>, and others like <code>filter</code>, <code>scan</code>, etc.</li>
</ol>
<p>However, the distinguishing feature of functional programming is the use of pure functions. The following Python code gives examples of pure and impure functions:</p>
<pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> pure_func(x):
    <span class="kw">return</span> <span class="dv">2</span>*x

<span class="kw">def</span> impure_func1(list1):
    list1.append(<span class="dv">5</span>)
    <span class="kw">return</span> list1[<span class="dv">0</span>]

<span class="kw">def</span> impure_func2(x):
    <span class="kw">print</span>(x)
    <span class="kw">return</span> <span class="dv">2</span>*x</code></pre>
<p>Pure and impure functions differ in that with pure functions, some thing like</p>
<pre class="sourceCode python"><code class="sourceCode python">x = func(a)
y = func(a)
z = func(a)</code></pre>
<p>can be replaced with an equivalent</p>
<pre class="sourceCode python"><code class="sourceCode python">x = func(a)
y = x
z = x</code></pre>
<p>This is not possible with impure functions, as must be clear from the above examples. Functional purity, also called <a href="http://en.wikipedia.org/wiki/Referential_transparency_(computer_science)">referential transparency</a>, seems to limit what functions are allowed to do. However, it gives very useful guarantees to someone reading and modifying the code. It tells you that a function takes some arguments as inputs and computes some value without any &quot;side-effects&quot;. It greatly simplifies understanding how different pieces of code are connected to each other. Pure functions have much simpler semantics. You just substitute symbols for their values and evaluate the function - there is no notion of some memory that is being updated over time. In fact, there is no notion of time itself. Computations are ordered only by dependency.</p>

        </div>
        <div id="footer">
            Site generated by <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
